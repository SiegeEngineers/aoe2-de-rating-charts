{"version":3,"file":"static/webpack/static\\development\\pages\\index.js.0e67a879bacafe2f3229.hot-update.js","sources":["webpack:///./pages/index.js"],"sourcesContent":["import React, { Component } from \"react\";\r\n\r\nconst got = require(\"got\");\r\nconst fs = require(\"fs\");\r\n\r\nexport default class extends Component {\r\n  state = {};\r\n\r\n  componentDidMount() {\r\n    let histogramArray = this.props.histogram;\r\n    let timestamp = this.props.timestamp ? this.props.timestamp : 0;\r\n\r\n    // Common chart variables\r\n    const FONT = \"Roboto, Arial, sans-serif\";\r\n\r\n    // Random Map Histogram\r\n    var randomMapScores = [];\r\n    for (var i = 0; i < histogramArray.length; i++) {\r\n      randomMapScores[i] = histogramArray[i][1];\r\n    }\r\n    var trace = {\r\n      x: randomMapScores,\r\n      type: \"histogram\"\r\n    };\r\n    var layout = {\r\n      title: {\r\n        text: \"Age of Empires II: Definitive Edition Ratings<br>1v1 Random Map\",\r\n        font: {\r\n          family: FONT,\r\n          size: 24\r\n        },\r\n        xref: \"paper\",\r\n        x: 0.05\r\n      },\r\n      xaxis: {\r\n        title: {\r\n          text: \"Rating\",\r\n          font: {\r\n            family: FONT,\r\n            size: 18,\r\n            color: \"#7f7f7f\"\r\n          }\r\n        }\r\n      },\r\n      yaxis: {\r\n        title: {\r\n          text: \"Number of Players\",\r\n          font: {\r\n            family: FONT,\r\n            size: 18,\r\n            color: \"#7f7f7f\"\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var data = [trace];\r\n    Plotly.newPlot(\"random_map_histogram\", data, layout);\r\n\r\n    // Team Random Map Histogram\r\n    var teamRandomMapScores = [];\r\n    for (var i = 0; i < histogramArray.length; i++) {\r\n      teamRandomMapScores[i] = histogramArray[i][2];\r\n    }\r\n    var trace = {\r\n      x: teamRandomMapScores,\r\n      type: \"histogram\"\r\n    };\r\n    var layout = {\r\n      title: {\r\n        text:\r\n          \"Age of Empires II: Definitive Edition Ratings<br>Team Random Map\",\r\n        font: {\r\n          family: FONT,\r\n          size: 24\r\n        },\r\n        xref: \"paper\",\r\n        x: 0.05\r\n      },\r\n      xaxis: {\r\n        title: {\r\n          text: \"Rating\",\r\n          font: {\r\n            family: FONT,\r\n            size: 18,\r\n            color: \"#7f7f7f\"\r\n          }\r\n        },\r\n        range: [600, 2600]\r\n      },\r\n      yaxis: {\r\n        title: {\r\n          text: \"Number of Players\",\r\n          font: {\r\n            family: FONT,\r\n            size: 18,\r\n            color: \"#7f7f7f\"\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var data = [trace];\r\n    Plotly.newPlot(\"team_random_map_histogram\", data, layout);\r\n\r\n    // Combo Scatterplot\r\n    var trace1 = {\r\n      x: randomMapScores,\r\n      y: teamRandomMapScores,\r\n      mode: \"markers\",\r\n      type: \"scatter\",\r\n      textposition: \"top center\",\r\n      textfont: {\r\n        family: FONT\r\n      },\r\n      marker: { size: 2 }\r\n    };\r\n\r\n    var data = [trace1];\r\n\r\n    var layout = {\r\n      legend: {\r\n        y: 0.5,\r\n        yref: \"paper\",\r\n        font: {\r\n          family: FONT,\r\n          size: 20,\r\n          color: \"grey\"\r\n        }\r\n      },\r\n      title: {\r\n        text:\r\n          \"Age of Empires II: Definitive Edition Ratings<br>Random Map vs Team Random Map Ratings\",\r\n        font: {\r\n          family: FONT,\r\n          size: 24\r\n        },\r\n        xref: \"paper\",\r\n        x: 0.05\r\n      },\r\n      xaxis: {\r\n        title: {\r\n          text: \"Random Map Rating\",\r\n          font: {\r\n            family: FONT,\r\n            size: 18,\r\n            color: \"#7f7f7f\"\r\n          }\r\n        },\r\n        range: [600, 2600]\r\n      },\r\n      yaxis: {\r\n        title: {\r\n          text: \"Team Random Map Rating\",\r\n          font: {\r\n            family: FONT,\r\n            size: 18,\r\n            color: \"#7f7f7f\"\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    Plotly.newPlot(\"combo_scatterplot\", data, layout);\r\n\r\n    let lastUpdatedDiv = document.getElementById(\"last_updated\");\r\n    lastUpdatedDiv.textContent = `Last updated: ${new Date(timestamp)}`;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <html>\r\n        <head>\r\n          <script\r\n            type=\"text/javascript\"\r\n            src=\"https://cdn.plot.ly/plotly-latest.min.js\"\r\n          ></script>\r\n        </head>\r\n        <body>\r\n          <div\r\n            id=\"random_map_histogram\"\r\n            style={{ width: \"900px\", height: \"500px\" }}\r\n          ></div>\r\n          <div\r\n            id=\"team_random_map_histogram\"\r\n            style={{ width: \"900px\", height: \"500px\" }}\r\n          ></div>\r\n          <div\r\n            id=\"combo_scatterplot\"\r\n            style={{ width: \"900px\", height: \"500px\" }}\r\n          ></div>\r\n          <div id=\"last_updated\"></div>\r\n          <div id=\"github_footer\">\r\n            Source code on{\" \"}\r\n            <a href=\"https://github.com/thbrown/aoe2-de-elo-histogram\">\r\n              Github\r\n            </a>\r\n            <br></br>\r\n            Data taken from\r\n            <a href=\"https://aoe2.net/#api\">https://aoe2.net/#api</a>\r\n          </div>\r\n        </body>\r\n      </html>\r\n    );\r\n  }\r\n}\r\n\r\nconst CACHE_DIRECTORY = \"cache/\";\r\nconst CACHE_FILE_NAME = \"ApiCache.json\";\r\nconst CACHE_EXPIRATION_IN_HOURS = 23; // Change this to 0 to bypass cache\r\nconst API_CALL_CHUNK_SIZE = 1000;\r\nconst API_CALL_DELAY_IN_MS = 2000;\r\n\r\n/**\r\n * This function only gets called when the page is built. It does not become a part of the web page. The return value of this function is\r\n * sent to the React component above as props.\r\n */\r\nexport async function getStaticProps(context) {\r\n  try {\r\n    let updatedTime = 0;\r\n\r\n    // Get the data\r\n    let randomMapLeaderboardResult = await getLeaderboardData(3);\r\n    let teamRandomMapLeaderboardResult = await getLeaderboardData(4);\r\n\r\n    let randomMapLeaderboard = randomMapLeaderboardResult.leaderboard;\r\n    let teamRandomMapLeaderbaord = teamRandomMapLeaderboardResult.leaderboard;\r\n    updatedTime = Math.min(\r\n      randomMapLeaderboardResult.updatedTime,\r\n      teamRandomMapLeaderboardResult.updatedTime\r\n    );\r\n\r\n    // Format the data\r\n    let aoeData = {}; // {\"steamId: [name, randomMapRating, teamRandomMapRating]\"}\r\n\r\n    for (let i = 0; i < randomMapLeaderboard.length; i++) {\r\n      let name = randomMapLeaderboard[i].name;\r\n      let steamId = randomMapLeaderboard[i].steam_id;\r\n      let soloRating = randomMapLeaderboard[i].rating;\r\n      aoeData[steamId] = [name, soloRating, null];\r\n    }\r\n\r\n    console.log(\r\n      \"Number of ranked random map players\",\r\n      randomMapLeaderboard.length\r\n    );\r\n\r\n    // Change 'numberOfPlayersToUse' to something like '1000' for development.\r\n    // You won't get all the data, but it will build MUCH faster after the API calls are cached.\r\n    let numberOfPlayersToUse = teamRandomMapLeaderbaord.length;\r\n    for (let i = 0; i < numberOfPlayersToUse; i++) {\r\n      let name = teamRandomMapLeaderbaord[i].name;\r\n      let steamId = teamRandomMapLeaderbaord[i].steam_id;\r\n      let teamRating = teamRandomMapLeaderbaord[i].rating;\r\n      if (aoeData[steamId] == undefined) {\r\n        aoeData[steamId] = [name, null, teamRating];\r\n      } else {\r\n        aoeData[steamId][2] = teamRating;\r\n      }\r\n    }\r\n\r\n    console.log(\r\n      \"Number of ranked team random map players\",\r\n      teamRandomMapLeaderbaord.length\r\n    );\r\n\r\n    let histogramData = [];\r\n    for (const property in aoeData) {\r\n      histogramData.push(aoeData[property]);\r\n    }\r\n\r\n    console.log(\"Total number of ranked players\", histogramData.length);\r\n\r\n    // Whatever happens after this takes forever, make sure the person who kicked off the build knows it's not hanging\r\n    console.log(\r\n      \"Doing nextjs stuff, this next step may take a few minutes if using all the players. Please be patient...\"\r\n    );\r\n\r\n    // the return calue will be passed to the page component as props\r\n    return {\r\n      props: {\r\n        histogram: histogramData,\r\n        timestamp: updatedTime\r\n      }\r\n    };\r\n  } catch (error) {\r\n    console.log(\"ERROR\" + error);\r\n    console.log(error);\r\n    return {\r\n      props: {}\r\n    };\r\n  }\r\n}\r\n\r\n//  Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4\r\nasync function getLeaderboardData(leaderboardId) {\r\n  let updatedTime = 0;\r\n  let leaderboard = [];\r\n  const CACHE_FILE_PATH = CACHE_DIRECTORY + leaderboardId + CACHE_FILE_NAME;\r\n  // Get the data -- If this API call has been cached in the last CACHE_EXPIRATION_IN_HOURS hours use the cached file\r\n  console.log(\r\n    \"Looking for cache file (\" + CACHE_FILE_PATH + \") modified within the last\",\r\n    CACHE_EXPIRATION_IN_HOURS,\r\n    \"hours...\"\r\n  );\r\n  if (\r\n    fs.existsSync(CACHE_FILE_PATH) &&\r\n    Date.now() - fs.statSync(CACHE_FILE_PATH).mtimeMs <\r\n      CACHE_EXPIRATION_IN_HOURS * 60 * 60 * 1000\r\n  ) {\r\n    console.log(\r\n      `Using cache file to avoid API calls to aoe2.net for leaderboard ${leaderboardId}...`\r\n    );\r\n    leaderboard = JSON.parse(fs.readFileSync(CACHE_FILE_PATH, \"utf8\"));\r\n    updatedTime = fs.statSync(CACHE_FILE_PATH).mtimeMs;\r\n  } else {\r\n    console.log(\r\n      `Fetching data from aoe2.net for leaderboard ${leaderboardId}...`\r\n    );\r\n    let firstResponse = await got(\r\n      `https://aoe2.net/api/leaderboard?game=aoe2de&leaderboard_id=${leaderboardId}&start=1&count=1`\r\n    ).json();\r\n    let numberOfRankedPlayers = firstResponse.total;\r\n\r\n    let numberOfRequests = Math.ceil(\r\n      numberOfRankedPlayers / API_CALL_CHUNK_SIZE\r\n    );\r\n\r\n    console.log(\r\n      \"It will require\",\r\n      numberOfRequests,\r\n      \"API requests to retrieve\",\r\n      numberOfRankedPlayers,\r\n      \"players\"\r\n    );\r\n\r\n    // The max number of leaderboard entries we can request is 1000, so we'll do it in chunks\r\n    for (let i = 0; i < numberOfRequests; i++) {\r\n      let startIndex = i * API_CALL_CHUNK_SIZE;\r\n      console.log(\r\n        \"Requesting\",\r\n        startIndex,\r\n        \"to\",\r\n        startIndex + API_CALL_CHUNK_SIZE\r\n      );\r\n\r\n      let dataResponse = await got(\r\n        `https://aoe2.net/api/leaderboard?game=aoe2de&leaderboard_id=${leaderboardId}&start=${startIndex}&count=${API_CALL_CHUNK_SIZE}`\r\n      ).json();\r\n      leaderboard = leaderboard.concat(dataResponse.leaderboard);\r\n\r\n      // Wait a litte bit between each api call. There are currently no API limits but still want to respect the server.\r\n      console.log(\"WAITING...\");\r\n      await new Promise(r => setTimeout(r, API_CALL_DELAY_IN_MS));\r\n    }\r\n\r\n    console.log(\"Total rows fetched\", leaderboard.length);\r\n\r\n    // Write the result to the file system cache so we don't have to make the api call each time we build\r\n    if (!fs.existsSync(CACHE_DIRECTORY)) {\r\n      fs.mkdirSync(CACHE_DIRECTORY);\r\n    }\r\n    fs.writeFile(CACHE_FILE_PATH, JSON.stringify(leaderboard), function(err) {\r\n      if (err) {\r\n        console.log(\"Error writing API cache file\");\r\n        console.log(err);\r\n        return;\r\n      }\r\n      console.log(\"API responses were cached\");\r\n    });\r\n    updatedTime = Math.floor(new Date() / 1000);\r\n  }\r\n  return {\r\n    updatedTime: updatedTime,\r\n    leaderboard: leaderboard\r\n  };\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;;;;;;;;;;;;;;;;AAKA;AACA;;;;;;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AApBA;AA+BA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AAQA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AAtBA;AAiCA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AAAA;AAAA;AATA;AAYA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAHA;AASA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AAQA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AA/BA;AA2CA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;AArMA;AACA;;;AA6MA;;;;;;;A","sourceRoot":""}