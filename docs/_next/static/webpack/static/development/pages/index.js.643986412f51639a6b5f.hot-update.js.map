{"version":3,"file":"static/webpack/static\\development\\pages\\index.js.643986412f51639a6b5f.hot-update.js","sources":["webpack:///./pages/index.js"],"sourcesContent":["import React, { Component } from 'react'\r\n\r\nconst got = require('got');\r\nconst fs = require('fs');\r\n\r\nexport default class extends Component {\r\n  state = { }\r\n\r\n  componentDidMount() {\r\n    let histogramArray = this.props.histogram;\r\n    let timestamp = this.props.timestamp ? this.props.timestamp : 0;\r\n    var x = [];\r\n    for (var i = 0; i < 100000; i ++) {\r\n        x[i] = Math.random() + Math.random() + Math.random() + Math.random();\r\n    }\r\n\r\n    var trace = {\r\n        x: x,\r\n        type: 'histogram'\r\n    }\r\n\r\n    var layout = {\r\n    title: {\r\n        text:'Plot Title',\r\n        font: {\r\n        family: 'Courier New, monospace',\r\n        size: 24\r\n        },\r\n        xref: 'paper',\r\n        x: 0.05,\r\n    },\r\n    xaxis: {\r\n        title: {\r\n        text: 'x Axis',\r\n        font: {\r\n            family: 'Courier New, monospace',\r\n            size: 18,\r\n            color: '#7f7f7f'\r\n        }\r\n        },\r\n    },\r\n    yaxis: {\r\n        title: {\r\n        text: 'y Axis',\r\n        font: {\r\n            family: 'Courier New, monospace',\r\n            size: 18,\r\n            color: '#7f7f7f'\r\n        }\r\n        }\r\n    }\r\n    };\r\n    var data = [trace];\r\n    Plotly.newPlot('chart_div', data, layout);\r\n\r\n    let lastUpdatedDiv = document.getElementById(\"last_updated\");\r\n    lastUpdatedDiv.textContent = `Last updated: ${new Date(timestamp)}`;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n        <html>\r\n            <head>\r\n            <script type=\"text/javascript\" src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\r\n            </head>\r\n            <body>\r\n            <div id=\"chart_div\" style={{width: \"900px\", height: \"500px\"}}></div>\r\n            <div id=\"last_updated\"></div>\r\n            <div id=\"github_footer\">\r\n                Source code on <a href=\"https://github.com/thbrown/aoe2-de-elo-histogram\">Github</a>  \r\n            </div>\r\n            </body>\r\n        </html>\r\n    )\r\n  }\r\n}\r\n\r\n//const NUMBER_OF_BUCKETS = 100;\r\nconst CACHE_DIRECTORY = \"cache/\";\r\nconst CACHE_FILE_PATH = CACHE_DIRECTORY + \"apiCache.json\";\r\nconst CACHE_EXPIRATION_IN_HOURS = 23; // Change this to 0 to bypass cache\r\nconst API_CALL_CHUNK_SIZE = 1000;\r\nconst API_CALL_DELAY_IN_MS = 2000;\r\n\r\n/**\r\n * This function gets called when only the page is built. It does not become a part of the web page. The resturn vale of this function are \r\n * sent to the React component above as props.\r\n */\r\nexport async function getStaticProps(context) {\r\n    try {\r\n        let updatedTime = 0;\r\n        let leaderboard = [];\r\n\r\n        // Get the data -- If this API call has been cached in the last CACHE_EXPIRATION_IN_HOURS hours use the cached file\r\n        if(fs.existsSync(CACHE_FILE_PATH) && Date.now() - fs.statSync(CACHE_FILE_PATH).mtimeMs < CACHE_EXPIRATION_IN_HOURS * 60 * 60 * 1000) {\r\n            console.log(\"Using cache to avoid API calls to aoe2.net...\");\r\n            leaderboard = JSON.parse(fs.readFileSync(CACHE_FILE_PATH, 'utf8'));\r\n            updatedTime = fs.statSync(CACHE_FILE_PATH).mtimeMs;\r\n        } else {\r\n            console.log(\"Fetching data from aoe2.net...\");\r\n            let firstResponse = await got('https://aoe2.net/api/leaderboard?game=aoe2de&leaderboard_id=3&start=1&count=1').json();\r\n            let numberOfRankedPlayers = firstResponse.total;\r\n\r\n            let numberOfRequests = Math.ceil(numberOfRankedPlayers/API_CALL_CHUNK_SIZE);\r\n\r\n            console.log(\"Number of API requests required\", numberOfRequests, \"to retrieve\", numberOfRankedPlayers, \"players\");\r\n\r\n            // The max number of leaderboard entries we can request is 1000, so we'll do it in chunks\r\n            for(let i = 0; i < numberOfRequests; i++) {\r\n                let startIndex = i * API_CALL_CHUNK_SIZE;\r\n                console.log(\"Requesting\",startIndex,\"to\",startIndex + API_CALL_CHUNK_SIZE)\r\n\r\n                let dataResponse = await got(`https://aoe2.net/api/leaderboard?game=aoe2de&leaderboard_id=3&start=${startIndex}&count=${API_CALL_CHUNK_SIZE}`).json();\r\n                leaderboard = leaderboard.concat(dataResponse.leaderboard);\r\n\r\n                // Wait a litte bit before we make the next api call\r\n                await new Promise(r => setTimeout(r, API_CALL_DELAY_IN_MS));\r\n            }\r\n\r\n            console.log(\"Leaderboard length\", leaderboard.length);\r\n\r\n            // Write the result to the file system cache so we don't have to make the api call each time we build\r\n            if (!fs.existsSync(CACHE_DIRECTORY)){\r\n                fs.mkdirSync(CACHE_DIRECTORY);\r\n            }\r\n            fs.writeFile(CACHE_FILE_PATH, JSON.stringify(leaderboard), function (err) {\r\n                if (err) {\r\n                    console.log(\"Error writing API cache file\");\r\n                    console.log(err);\r\n                    return;\r\n                }                \r\n                console.log(\"API response written to cache\")\r\n            });\r\n            updatedTime = Math.floor(new Date()/1000);\r\n        }\r\n\r\n        // Format the data\r\n        let histogramData = [];\r\n        for(let i = 0; i < 1000; i++) {\r\n            let name = leaderboard[i].name;\r\n            let rating = leaderboard[i].rating;\r\n            histogramData.push([name, rating]);\r\n        }\r\n\r\n        console.log(\"Number of ranked players\", histogramData.length);\r\n        console.log(\"The next step may take a few minutes depending on the number of players...\")\r\n\r\n        // will be passed to the page component as props\r\n        return {\r\n            props: {\r\n                histogram: histogramData,\r\n                timestamp: updatedTime\r\n            } \r\n        }\r\n    } catch (error) {\r\n        console.log(\"ERROR\" + error);\r\n        console.log(error);\r\n        return {\r\n            props: {}\r\n        }\r\n    }\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;;;;;;;;;;;;;;;;AAKA;AACA;;;;;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AApBA;AA+BA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;AArEA;AACA;AACA;;;AA6EA;;;;;;;A","sourceRoot":""}